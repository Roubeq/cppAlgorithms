# Алгоритм Дейкстры(поиск кратчайшего пути от одной вершины графа (источника) до всех остальных)

## Структура узла графа
- номер вершины
- вес ребра
- ссылка на следующую вершину(узел вершин)

## Структура графа
- Node** graph, тобишь просто сам граф
- размер графа, количество вершин

## Описание
- Конструктор графа нужен для того чтобы заполнить все вершины nullptr'ами. В деструкторе наоборот всё очищается.
- Функция добавления узла создает узел, добавляет в ссылку на след элемент этого нового узла, ссылку того элемента, в который мы его хотим добавить и потом просто
  меняем ссылку того элемента на этот новый, тобишь узел просто вперед встаёт, можно представить список у элемента. И так же добавляет его в другой узел, обратный,
  так как граф в этом случае у нас неориентированный.
- Функция Дейкстры. Она принимает на вход вершину, с которой мы хотим начать
  1. Первым шагом сразу же создаем массив расстояний до всех точек, и в 0 кладем наше расстояние 0, так как мы в ней находимся сейчас.
  2. Создаем приоритетную очередь MinHeap и делаем цикл пока очередь не пустая, вытаскиываем из нее значение пары в отдельные переменные и извлекаем элемент из очереди.
  3. Делаем проверку, оптимизируем таким образом наш алгоритм, проверяем больше ли эта извлеченная дистанция в этой вершине, чем записанная в список, если да, то просто
     continue.
  4. Создаем соседа, и делаем цикл пока сосед не пустой, создаем две переменные, в первой у нас номер вершины, во второй новая дистанция, тоесть дистанция до текущей точки
     (distance[current]) + дистанция до этого соседа, и потом делаем проверку, если эта дистанция меньше чем дистанция этого соседа, то записываем вместо нее туда newDist
     и пушим соседа этого в очередь с этим расстоянием до него, ну и потом переключаем на следующего соседа.
Таким образом в списке distance будут храниться все расстояния(минимальные) до всех вершин от выбранной точки. Это допустим можно использовать в навигаторах для поиска
кратчайшего пути.
