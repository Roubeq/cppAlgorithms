# Операции сложения и умножения полиномов с помощью Linked List

## Структура узла
```cpp
struct Node {
  float coeff;
  int expo;
  struct Node* link;
```
coeff - отвечает за коэффициент перед членом
expo - степень этого члена
*link - ссылка на следующий член

## Создание полинома
Для создания полинома используется ввод с клавиатуры:
 - Вводится количество членов
 - Вводится коэффициент члена
 - Вводится степень члена
 - Далее происходит вставка в head каждого узла при помощи функции
   ```cpp
   insert(struct Node* head, float data, int exp)
   ```
### Функция insert()
Эта функция нужна для вставки в полином отдельных его частей(членов полинома). Она работает следующим образом - создается новый узел, ему придаются значения,
переданные в параметры функции. Затем проверяется, если head == nullptr, то узел становится head, иначе, запускается цикл, который идет до момента, пока наша
степень многочлена, не станет больше, чем степень текущего узла полинома, и только тогда она вставляется на это место.

## Умножение полиномов
```cpp
struct Node* polyMultiplication(struct Node* head1, struct Node* head2)
```
- принимает на вход два полинома.
1. Создаем временные головы и третью для результата.
2. Цикл while, пока первый не пустой, пока второй не пустой, вставляем в третью голову (head3; умножаем коэффы 1 на коэффы 2; складываем степени),
    и берем следующий узел второй головы, после второго цикла, берем следующий узел 1 головы и так же сбрасываем до head вторую голову.
3. Далее нам нужно сложить все узлы с одинаковыми степенями, мы проходимся по третьей голове и ищем, есть ли узел.коэфф = узел.линк.коэфф, если да то
   ставим временный указатель на следующий узел, в текущий складываем коэффы, текущему даем ссылку на следующий после временного и удаляем прошлый.

## Сложение полиномов
```struct Node* polyAdd(struct Node* head1, struct Node* head2)```
1. Создаем временные головы и третью для результата.
2. Цикл while, пока 1 не налл и 2 не налл. Проверяем, если степени равны, то добавляем в 3 голову результат сложения и перелистываем на следующие узлы.
   Если нет, то проверяем если степень 1 больше степени 2, то добавляем в голову этот узел. Так как степени у нас по порядку идут. И так же если нет, то проверяем
   степень 2 больше чем 1 соответственно.
3. Теперь у нас может быть остаток в каком то одном узле, и мы его тоже должны вставить в результирующую голову.
