# Реализация хеш-таблицы

У класса HashTable есть свойство struct Entry - запись в таблице, у нее тем временем есть ключ, значение и bool isActive.

Функция ```void rehash()```.
Рехеширование хеш таблицы нужно, когда заполнение таблицы переполняет заданное значение, при этом, этот процесс заключается в расширении таблички, и все хеши,
которые были вычислены до, будут перевычеслены для каждого Entry и заново помещены в таблицу.
В данном проекте рехеширование происходит следующим образом: создается новый размер таблички и умножается на 3. Создается новая табличка с этим размером.
Далее происходит рехеширование, все элементы со старой таблички копируются в новую с помощью функции ```void insert(int key, int value)```.
Размеры таблички лучше делать простыми числами, так как будут работать больше методов разрешения коллизий. Допустим если просто увеличивать размер таблички вдвое, то
все равно делиться будет на 4 допустим, тобишь будет больше коллизий, если мы не сделаем с простыми числами.

Функция ```void insert(int key, int value)```.
Вставка элемента происходит не простым образом, а довольно сложным. Для начала идёт проверка, не переполнилась ли табличка, если да, то вызываем ```rehash()```.
Иначе вычисляем хеш для ключа, с помощью функции хеширования на выбор, в данном случае ```int hashMultiplication(int& key)```. Эта функция вычисляет хеш 
способом умножения ключа на "золотое сечение", после возвращает результат умножения размера таблички на это число(число*золотое - число округленное вниз).
После происходит вставка элемента в таблицу, цикл начинается сразу же с квадратичным пробированием(метод разрешения коллизий), при этом методе, если
ячейка с индексом результата хеш функции занята, то ищется следующая по формуле [index + i * i % sizeTable], а после просто вставляется на эту позицию в таблице
и увеличивается счетчик элементов в табличке.
Разрешение коллизий тоже может происходить разными способами, еще самый популярный, и мне близкий способ - разрешение коллизий с помощью цепочек, тобишь когда вместо
элемента в ячейке таблички хранится связный список. И туда добавляются числа по очереди.

Функция ```void remove(int keyForRemove)```.
Эта функция позволяет нам удалить элемент из хеш таблицы по ключу.
Тут все легко, как вставлялось так и ищется, тобишь по квадратичному пробированию, а потом просто все обнуляется и isActive() ставится фолс, а также кол-во элементов--ю

Функцию ```void search(int searchKey)```.
Поиск тоже происходит таким же образом как и удаление по сути, только проверяется просто и пишет в консоль нашло или нет.
