# Деревья и операции над ними

## Бинарное дерево
## Структура узла бинарного дерева
Она состоит из переменной данных и ссылки на левого и правого потомка.
## Структура бинарного дерева
У самого класса дерева есть только одна переменная - его корня.

## Алгоритмы обхода и поиска
1. Алгоритм __pre-order-traversal__ - этот алгоритм, как и все последующие можно реализовать двумя способами:
   1.1 Способ через рекурсию:
   - Сначала выводим данные текущего узла, а потом вызываем эту же функцию для левого и после для правого узла.
   - Чтобы выйти из рекурсии, нужно прописать if, в котором проверить равен ли узел nullptr, если да то return.
   1.2 Итеративный способ:
   - Создается стек и в него добавляется head, сразу же.
   - Цикл while пока стек не пустой, кладем в переменную узел с вершины стека и вынимаем его из стека и печатаем.
   - После проверяем есть ли правый, если да то кладём в стек.
   - После проверяем есть ли левый, если да то кладём в стек.
   - (Из-за особенности стека, LIFO, мы сначала кладём в стек правого, а потом левого потомка.
2. Алгоритм __in-order-traversal__ - имеет два способа реализации:
   2.1 - Через рекурсию, как в 1.1, только теперь сначала обрабатывается левый потомок.
   2.2 - Итеративный способ:
   - Создается новый указатель и дается значение головы и создается стек.
   - Цикл while пока новый указатель не равен nullptr И стек не пустой.
   - Вложенный while пока current != nullptr, мы его кладем в стек и даем ему значение левого потомка.
   - Вне вложенного цикла: current = вершине стека, выводим его, после поп() из стека и current = правый потомок.
3. Алгоритм __post-order-traversal__ - можно реализовать двумя способами:
   3.1 - Рекурсивный, такой же как и в 1.1, только текущий узел обрабатывается после левого и правого.
   3.2.1 - Итеративный способ:
   - Создаем два стека s1 и s2, и в первый сразу же пушим root, корень дерева.
   - Пока s1 не пустой, цикл while, создаем узел, даем значение вершины s1 и удаляем из s1 и добавляем в s2, после пушим левый потомок в s1 и правый в s1, а потом
     просто выводим s2.
   3.2.2 - Итеративный способ(меньше памяти):
     - Создаем так же указатель на узел, стек, пушим в стек корень.
     - Пока стек не пустой, создаем указатель на вершину стека, удаляем со стека, добавляем левый, правый, после пушим в список значение текущего, после цикла
       переворачиваем список.
4. Алгоритм обхода в ширину BFS
   - Создается очередь и в нее сразу закидывается корень.
   - Идет цикл, пока очередь не пустая, создается указатель на верхний элемент очереди(первый), потом оттуда удаляется, выводится узел,
     добавляется левый, потом правый. Именно в порядке очереди просто элементы добавляются
5. Алгоритм обхода в глубину DFS это по сути просто первые 3 обхода.
